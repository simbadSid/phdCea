%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------
\documentclass[11pt]{article}											% font size

\usepackage[english]{babel}												% set language

\usepackage{amssymb}
\usepackage{amsmath,amsfonts}
\usepackage{subfig}
\usepackage{graphicx}													% to include images
\usepackage{float}														% to float figures
\usepackage{booktabs,makecell}											% for diagonal cells
\usepackage{hyperref}													% for hyperlinks
\usepackage{listings}													% for including files
\usepackage[top=1in, bottom=1in, left=1.25in, right=1.25in]{geometry}	% set margins
\usepackage[utf8]{inputenc}												% for unicode input characters
\usepackage{helvet}														% use helvetica per default
\usepackage{hyperref}													% for hyperlinks
\usepackage[T1]{fontenc}
\usepackage{color}

\renewcommand{\familydefault}{\sfdefault}								% use sans serif per default

\definecolor{codegreen}{rgb}{0,0.6,0}									%New colors defined below
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}												%Code listing style named "mystyle"
{
	backgroundcolor=\color{backcolour},
	commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2
}

\lstset{style=mystyle}													%"mystyle" code listing set

% ----------------------------------------------------------------------------------------
%	NOTATIONS
% ----------------------------------------------------------------------------------------
	\newcommand{\targetname}			{\emph{LGen}}
	\newcommand{\targetnameStatement}	{\emph{$\Sigma-$CLooG}}


% ----------------------------------------------------------------------------------------
%	TITLE SECTION 
% ----------------------------------------------------------------------------------------

\makeatletter
\makeatother
\renewcommand{\familydefault}{\sfdefault}								% use sans serif per default
\makeatother
\title
{
	PhD CEA pre-assignment.   Summarizing the paper: \\
	\emph{A Basic Linear Algebra Compiler For Structured Matrices\cite{mainPaper}}
}
\author{Riyane SID-LAKHDAR}
\date{\today}


\begin{document}
\maketitle

%\begin{abstract}
%blabla
%\end{abstract}

\tableofcontents
\newpage



%----------------------------------------------------------------------------
\section{Context: high performance computation on matrices}
	%**** Computation of large scale matrices at high performance for multiple scientific computations
	The computation (linear algebra) of matrices is a compulsory service for numerous scientific problems.   Hence the need to have an efficient framework for such operations.\\
	%**** Complex for software developers (non specialists in high performance computing) to optimize this matrix computations (reduce the number of idle/redundant computations) and adapt it to the hardware specifications (ex: \emph{vectorized Instruction Set Architecture} (ISA))
	In this context, optimizing a matrices-computation comes to reducing the number of idle/redundant computations (scalar).   It also comes to adapt the corresponding code to the host hardware (ex: group the scalar computation for \emph{vectorized Instruction Set Architecture}).


%----------------------------------------------------------------------------
\section{The \targetname}\label{section:background}
	%******* Define the \targetname on an input BLAC
	The \targetname\space is a compiler that generates an optimized C code corresponding to an input basic linear algebra computation (BLAC).
	%******* Define the working process:
	For a given BLAC, the \targetname\space first splits the input matrices into blocks (tiles) with respect to a fixed granularity.   The resultant (linear language (LL)) expression is transformed into a $\Sigma-$LL expression\footnote{Made of sums and products of tiles} using the custom-defined gather and scatter matrix-operators.   Thanks to the associativity, commutativity and distributivity properties of these operators, the resultant expression is simplified (in terms of number of accesses and indexes on the matrices).   A C code is then generated by mapping each element\footnote{Sum, BLAC, gather and scatter operators} of the $\Sigma-$LL expression to a predefined code pattern.\\
	This whole process is repeated and the performances of each generated code are assessed to pick the best variant.\\

	%******* Interest of the \targetname: Optimized C code + Efficient for dense matrices + optimizations target both small and large scale matrices + takes into account the architecture (vectorized ISA)
	On one hand, the interest of the generated C code is its efficiency on dense matrices (matrices with few zero-blocks and no particular geometrical property).   This efficiency-goal targets both small and large scale matrices.   Finally, the code generated by \targetname\space might be adapted to vectorized hardware architectures (by adapting the granularity of the initially-generated tiles to the hardware-vector size).\\
%	******* Limitation: Might lead to process redundant computations when the matrix has spares regions
	On the other hand, \targetname\space might lead to process redundant/idle computations when the matrix has spares regions (zero-blocks) or has some symmetry/geometrical properties.


\section{Enhancing the \targetname\space for structured matrices}
	%******* Specification (structured matrices)
	To tackle the previous limitations, \cite{mainPaper} proposes to first identify structured input-matrices.   Then split each one of these inputs into regions according to their specific properties (ex: zero-block, or symmetric block).
	%******* Define the working process: 
	The previously-defined $\Sigma-$LL expression is then generated using \targetnameStatement.   This loop generator transforms the input BLAC (once tilled) into a set of CLooG statements.   Each statement specifies the indexes (domain) used to scan a region of a matrix and the order (schedule) to use these indexes.    \targetnameStatement\space associates each statement to a specific $\Sigma-$LL expression.   Finally, thanks to set-theory operations, this statements are processed to generate a single statement (or a linear combination of statements).   The associated $\Sigma-$LL expression represents an optimal C code of the input BLAC (and might then be generated as explained in section \ref{section:background}).\\

	%******* Interest (what makes it different from other libraries that optimize code generation following structured matrices): evolutivity: the method might be extansible to handle user-defined structured matrices
	The generated $\Sigma-$LL expression (and the corresponding C code) has now no redundant computations\footnote{Computation on zero-blocks or multiple computations on symmetrical blocks}.   Furthermore, unlike other structured-matrices library (ex: BLAS), the \targetname\space may (easily) handle new (user-defined) structured matrices.


%	******* Maybe add a paragraphe on the performances of the generated C code.



%----------------------------------------------------------------------------
%\section{Limitation}
	%****** The generated code is purely monothreaded: Given that the input expression is divided into tiles, we could easily expect the loops (summation on these tiles) to be parallel: the computation
%	First, we can notice that the generated C code is purely mono-threaded (for both versions of \targetname).   It could thus be 


	%****** \targetname\space autotuning: done through perf evaluations of different resulting code.   But the code-generation process looks deterministic.   So how can we end up with different variants


%----------------------------------------------------------------------------------------
%	REFERENCES
%----------------------------------------------------------------------------------------
%\newpage
\nocite{*}
\small{\bibliographystyle{abbrv}
\bibliography{bibliography.bib}\vspace{0.75in}}


\end{document}
